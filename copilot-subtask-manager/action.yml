name: 'Copilot Subtask Manager'
description: 'Automatically assigns GitHub Copilot to ready subtasks for parallel work'
author: 'cajias'

branding:
  icon: 'git-branch'
  color: 'green'

inputs:
  token:
    description: 'GitHub token for API access (requires issues: write permission)'
    required: true

  ai-token:
    description: >-
      GitHub token for AI/MCP access (requires repo scope).
      If not provided, basic dependency parsing is used.
    required: false
    default: ''

  model:
    description: 'AI model to use for dependency analysis'
    required: false
    default: 'openai/gpt-4o'

  max-tokens:
    description: 'Maximum tokens for AI response'
    required: false
    default: '1500'

  enable-ai-analysis:
    description: 'Enable AI-powered dependency analysis (requires ai-token)'
    required: false
    default: 'false'

  copilot-username:
    description: 'Username of the Copilot bot (default: copilot-swe-agent)'
    required: false
    default: 'copilot-swe-agent'

outputs:
  parent-issue-number:
    description: 'The parent issue number'
    value: ${{ steps.identify-parent.outputs.parent_number }}

  assigned-subtasks:
    description: 'Comma-separated list of subtask issue numbers that were assigned to Copilot'
    value: ${{ steps.assign-subtasks.outputs.assigned_subtasks }}

  skipped-subtasks:
    description: 'Comma-separated list of subtask issue numbers that were skipped'
    value: ${{ steps.assign-subtasks.outputs.skipped_subtasks }}

runs:
  using: 'composite'
  steps:
    - name: Detect Trigger Type
      id: detect-trigger
      shell: bash
      run: |
        echo "Event: ${{ github.event_name }}"

        # Check if this is an assignment event
        event_name="${{ github.event_name }}"
        event_action="${{ github.event.action }}"
        if [[ "$event_name" == "issues" ]] && [[ "$event_action" == "assigned" ]]; then
          echo "trigger_type=assignment" >> $GITHUB_OUTPUT
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "assignee=${{ github.event.assignee.login }}" >> $GITHUB_OUTPUT
        # Check if this is a PR closed event
        elif [[ "${{ github.event_name }}" == "pull_request" ]] && [[ "${{ github.event.action }}" == "closed" ]]; then
          echo "trigger_type=pr_closed" >> $GITHUB_OUTPUT
          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "pr_merged=${{ github.event.pull_request.merged }}" >> $GITHUB_OUTPUT
        else
          echo "trigger_type=unknown" >> $GITHUB_OUTPUT
        fi

    - name: Check if Copilot was Assigned
      id: check-copilot
      if: steps.detect-trigger.outputs.trigger_type == 'assignment'
      shell: bash
      run: |
        assignee="${{ steps.detect-trigger.outputs.assignee }}"
        copilot_user="${{ inputs.copilot-username }}"

        if [[ "$assignee" == "$copilot_user" ]]; then
          echo "is_copilot=true" >> $GITHUB_OUTPUT
          echo "âœ… Copilot ($copilot_user) was assigned"
        else
          echo "is_copilot=false" >> $GITHUB_OUTPUT
          echo "â„¹ï¸ Not a Copilot assignment (assignee: $assignee)"
        fi

    - name: Get Issue Details
      id: get-issue
      if: steps.detect-trigger.outputs.trigger_type == 'assignment' && steps.check-copilot.outputs.is_copilot == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const issue_number = ${{ steps.detect-trigger.outputs.issue_number }};

          const { data: issue } = await github.rest.issues.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number
          });

          core.setOutput('number', issue.number);
          core.setOutput('title', issue.title);
          core.setOutput('body', issue.body || '');
          const hasTasklist = (issue.body || '').includes('- [ ] #') ||
                              (issue.body || '').includes('- [x] #');
          core.setOutput('has_tasklist', hasTasklist);

          return issue;

    - name: Identify if This is Parent Issue
      id: identify-parent
      if: steps.detect-trigger.outputs.trigger_type == 'assignment' && steps.check-copilot.outputs.is_copilot == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const issue_number = ${{ steps.get-issue.outputs.number }};
          const body = `${{ steps.get-issue.outputs.body }}`;

          // Check if issue has a tasklist (indicates parent issue)
          const hasTasklist = body.includes('- [ ] #') ||
                              body.includes('- [x] #');

          if (hasTasklist) {
            core.info('âœ… This is a parent issue with subtasks');
            core.setOutput('is_parent', 'true');
            core.setOutput('parent_number', issue_number);
          } else {
            core.info('â„¹ï¸ This is not a parent issue (no tasklist found)');
            core.setOutput('is_parent', 'false');
          }

    - name: Extract Subtasks
      id: extract-subtasks
      if: steps.identify-parent.outputs.is_parent == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const body = `${{ steps.get-issue.outputs.body }}`;

          // Extract issue numbers from tasklist (format: - [ ] #123 or - [x] #123)
          const regex = /- \[([ x])\] #(\d+)/g;
          const subtasks = [];
          let match;

          while ((match = regex.exec(body)) !== null) {
            const isCompleted = match[1] === 'x';
            const issueNumber = parseInt(match[2], 10);

            if (!isCompleted) {
              subtasks.push(issueNumber);
            }
          }

          core.info(`Found ${subtasks.length} incomplete subtasks: ${subtasks.join(', ')}`);
          core.setOutput('subtask_numbers', subtasks.join(','));
          core.setOutput('subtask_count', subtasks.length);

          return subtasks;

    - name: Get Subtask Details
      id: get-subtask-details
      if: steps.extract-subtasks.outputs.subtask_count > 0
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const subtaskNumbersStr = '${{ steps.extract-subtasks.outputs.subtask_numbers }}';
          const subtaskNumbers = subtaskNumbersStr.split(',').map(n => parseInt(n, 10));
          const subtaskDetails = [];

          for (const subtaskNumber of subtaskNumbers) {
            try {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: subtaskNumber
              });

              // Check if already assigned to someone
              const assignees = issue.assignees.map(a => a.login);
              const isAssigned = assignees.length > 0;

              subtaskDetails.push({
                number: issue.number,
                title: issue.title,
                body: issue.body || '',
                state: issue.state,
                assignees: assignees,
                isAssigned: isAssigned,
                labels: issue.labels.map(l => l.name)
              });

              core.info(`Subtask #${subtaskNumber}: ${issue.title} (assigned: ${isAssigned})`);
            } catch (error) {
              core.warning(`Could not fetch subtask #${subtaskNumber}: ${error.message}`);
            }
          }

          core.setOutput('subtasks_json', JSON.stringify(subtaskDetails));
          return subtaskDetails;

    - name: Parse Dependencies
      id: parse-dependencies
      if: steps.extract-subtasks.outputs.subtask_count > 0
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const subtasks = JSON.parse(`${{ steps.get-subtask-details.outputs.subtasks_json }}`);
          const dependencyMap = {};

          for (const subtask of subtasks) {
            const dependencies = [];

            // Check labels for depends-on:#123 format
            for (const label of subtask.labels) {
              const match = label.match(/^depends-on:#?(\d+)$/i);
              if (match) {
                dependencies.push(parseInt(match[1], 10));
              }
            }

            // Check body for explicit dependency mentions
            // Patterns: "Depends on #123", "Requires #123", "Blocked by #123"
            const body = subtask.body || '';
            const patterns = [
              /depends on #(\d+)/gi,
              /requires #(\d+)/gi,
              /blocked by #(\d+)/gi,
              /dependency:\s*#(\d+)/gi
            ];

            for (const pattern of patterns) {
              let match;
              while ((match = pattern.exec(body)) !== null) {
                const depNumber = parseInt(match[1], 10);
                if (!dependencies.includes(depNumber)) {
                  dependencies.push(depNumber);
                }
              }
            }

            dependencyMap[subtask.number] = dependencies;
            core.info(`Subtask #${subtask.number} depends on: [${dependencies.join(', ')}]`);
          }

          core.setOutput('dependency_map', JSON.stringify(dependencyMap));
          return dependencyMap;

    - name: AI-Powered Dependency Analysis
      id: ai-analysis
      if: |
        steps.extract-subtasks.outputs.subtask_count > 0 &&
        inputs.enable-ai-analysis == 'true' &&
        inputs.ai-token != ''
      uses: actions/ai-inference@v2.0.1
      with:
        model: ${{ inputs.model }}
        max-tokens: ${{ inputs.max-tokens }}
        enable-github-mcp: true
        github-mcp-token: ${{ inputs.ai-token }}
        system-prompt: |
          You are an expert at analyzing task dependencies in software projects.

          Analyze the subtasks and determine which ones depend on others. Return ONLY this JSON structure:
          {
            "dependencies": {
              "123": [456, 789],
              "456": []
            },
            "circular_dependencies": [],
            "reasoning": "Brief explanation"
          }

          The "dependencies" object maps each subtask number to an array of issue numbers it depends on.
          If there are circular dependencies, list them in "circular_dependencies" array.
        prompt: |
          Analyze these subtasks and their dependencies:

          Parent Issue: #${{ steps.get-issue.outputs.number }} - ${{ steps.get-issue.outputs.title }}

          Subtasks:
          ${{ steps.get-subtask-details.outputs.subtasks_json }}

          Respond with ONLY the JSON structure specified in your instructions.

    - name: Merge AI Dependencies
      id: merge-dependencies
      if: steps.ai-analysis.outcome == 'success'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const basicDeps = JSON.parse(`${{ steps.parse-dependencies.outputs.dependency_map }}`);
          const aiResponse = `${{ steps.ai-analysis.outputs.response }}`;

          try {
            // Extract JSON from AI response
            let jsonText = aiResponse.replace(/^```json\s*/m, '').replace(/\s*```\s*$/m, '');
            const jsonMatch = jsonText.match(/\{[\s\S]*\}/);

            if (jsonMatch) {
              const aiAnalysis = JSON.parse(jsonMatch[0]);
              const aiDeps = aiAnalysis.dependencies || {};

              // Merge AI dependencies with basic parsing (AI takes precedence)
              const mergedDeps = { ...basicDeps };

              for (const [subtask, deps] of Object.entries(aiDeps)) {
                mergedDeps[subtask] = deps;
              }

              core.setOutput('dependency_map', JSON.stringify(mergedDeps));
              core.setOutput('circular_deps', JSON.stringify(aiAnalysis.circular_dependencies || []));
              core.info('âœ… AI analysis merged with basic parsing');
              return mergedDeps;
            } else {
              core.warning('Could not extract JSON from AI response, using basic parsing');
              core.setOutput('dependency_map', JSON.stringify(basicDeps));
              core.setOutput('circular_deps', '[]');
            }
          } catch (error) {
            core.warning(`AI analysis parsing failed: ${error.message}, using basic parsing`);
            core.setOutput('dependency_map', JSON.stringify(basicDeps));
            core.setOutput('circular_deps', '[]');
          }

    - name: Identify Ready Subtasks
      id: identify-ready
      if: steps.extract-subtasks.outputs.subtask_count > 0
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const subtasks = JSON.parse(`${{ steps.get-subtask-details.outputs.subtasks_json }}`);
          const depMapRaw = `${{
            steps.merge-dependencies.outputs.dependency_map ||
            steps.parse-dependencies.outputs.dependency_map
          }}`;
          const dependencyMap = JSON.parse(depMapRaw);

          const readySubtasks = [];
          const blockedSubtasks = [];
          const skippedSubtasks = [];

          for (const subtask of subtasks) {
            // Skip if already assigned
            if (subtask.isAssigned) {
              skippedSubtasks.push({
                number: subtask.number,
                reason: `Already assigned to: ${subtask.assignees.join(', ')}`
              });
              continue;
            }

            // Skip if closed
            if (subtask.state === 'closed') {
              skippedSubtasks.push({
                number: subtask.number,
                reason: 'Already closed'
              });
              continue;
            }

            // Check dependencies
            const dependencies = dependencyMap[subtask.number] || [];

            if (dependencies.length === 0) {
              readySubtasks.push(subtask.number);
              core.info(`âœ… Subtask #${subtask.number} is ready (no dependencies)`);
            } else {
              // Check if all dependencies are resolved (closed)
              let allResolved = true;

              for (const depNumber of dependencies) {
                try {
                  const { data: depIssue } = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: depNumber
                  });

                  if (depIssue.state !== 'closed') {
                    allResolved = false;
                    break;
                  }
                } catch (error) {
                  core.warning(`Could not check dependency #${depNumber}: ${error.message}`);
                  allResolved = false;
                  break;
                }
              }

              if (allResolved) {
                readySubtasks.push(subtask.number);
                core.info(`âœ… Subtask #${subtask.number} is ready (all dependencies resolved)`);
              } else {
                blockedSubtasks.push({
                  number: subtask.number,
                  dependencies: dependencies
                });
                core.info(`â¸ï¸ Subtask #${subtask.number} is blocked by: [${dependencies.join(', ')}]`);
              }
            }
          }

          core.setOutput('ready_subtasks', readySubtasks.join(','));
          core.setOutput('ready_count', readySubtasks.length);
          core.setOutput('blocked_subtasks', JSON.stringify(blockedSubtasks));
          core.setOutput('skipped_subtasks', JSON.stringify(skippedSubtasks));

          return { ready: readySubtasks, blocked: blockedSubtasks, skipped: skippedSubtasks };

    - name: Assign Copilot to Ready Subtasks
      id: assign-subtasks
      if: steps.identify-ready.outputs.ready_count > 0
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const readySubtasksStr = '${{ steps.identify-ready.outputs.ready_subtasks }}';
          const readySubtasks = readySubtasksStr.split(',').map(n => parseInt(n, 10));
          const copilotUser = '${{ inputs.copilot-username }}';
          const assignedSubtasks = [];
          const failedAssignments = [];

          for (const subtaskNumber of readySubtasks) {
            try {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: subtaskNumber,
                assignees: [copilotUser]
              });

              assignedSubtasks.push(subtaskNumber);
              core.info(`âœ… Assigned Copilot to subtask #${subtaskNumber}`);
            } catch (error) {
              failedAssignments.push({
                number: subtaskNumber,
                error: error.message
              });
              core.warning(`âŒ Failed to assign Copilot to subtask #${subtaskNumber}: ${error.message}`);
            }
          }

          core.setOutput('assigned_subtasks', assignedSubtasks.join(','));
          core.setOutput('assigned_count', assignedSubtasks.length);
          core.setOutput('failed_assignments', JSON.stringify(failedAssignments));

          return { assigned: assignedSubtasks, failed: failedAssignments };

    - name: Post Status Comment
      if: steps.identify-parent.outputs.is_parent == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const parentNumber = ${{ steps.identify-parent.outputs.parent_number }};
          const readySubtasksStr = '${{ steps.identify-ready.outputs.ready_subtasks }}';
          const readySubtasks = readySubtasksStr.split(',').filter(n => n);
          const assignedSubtasksStr = '${{ steps.assign-subtasks.outputs.assigned_subtasks }}';
          const assignedSubtasks = assignedSubtasksStr.split(',').filter(n => n);
          const blockedSubtasks = JSON.parse(`${{ steps.identify-ready.outputs.blocked_subtasks }}`);
          const skippedSubtasks = JSON.parse(`${{ steps.identify-ready.outputs.skipped_subtasks }}`);
          const subtasks = JSON.parse(`${{ steps.get-subtask-details.outputs.subtasks_json }}`);

          let comment = `## ðŸ¤– Copilot Subtask Manager\n\n`;
          comment += `Copilot has been assigned to this parent issue. Analyzing subtasks...\n\n`;

          // Assigned subtasks
          if (assignedSubtasks.length > 0) {
            comment += `### âœ… Auto-assigned to Copilot (${assignedSubtasks.length})\n\n`;
            for (const num of assignedSubtasks) {
              const subtask = subtasks.find(s => s.number == num);
              if (subtask) {
                comment += `- #${num} - ${subtask.title}\n`;
              }
            }
            comment += `\n`;
          } else {
            comment += `### â„¹ï¸ No subtasks ready for assignment\n\n`;
          }

          // Blocked subtasks
          if (blockedSubtasks.length > 0) {
            comment += `### â¸ï¸ Blocked by dependencies (${blockedSubtasks.length})\n\n`;
            for (const blocked of blockedSubtasks) {
              const subtask = subtasks.find(s => s.number === blocked.number);
              if (subtask) {
                const depLinks = blocked.dependencies.map(d => `#${d}`).join(', ');
                comment += `- #${blocked.number} - ${subtask.title}\n`;
                comment += `  - Dependencies: ${depLinks}\n`;
              }
            }
            comment += `\n`;
          }

          // Skipped subtasks
          if (skippedSubtasks.length > 0) {
            comment += `### â­ï¸ Skipped (${skippedSubtasks.length})\n\n`;
            for (const skipped of skippedSubtasks) {
              const subtask = subtasks.find(s => s.number === skipped.number);
              if (subtask) {
                comment += `- #${skipped.number} - ${subtask.title}\n`;
                comment += `  - Reason: ${skipped.reason}\n`;
              }
            }
            comment += `\n`;
          }

          comment += `---\n`;
          comment += `*Copilot will be automatically assigned to blocked subtasks `;
          comment += `once their dependencies are resolved.*`;

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: parentNumber,
            body: comment
          });

          core.info('âœ… Posted status comment on parent issue');

    - name: Handle PR Closed Event
      id: handle-pr-closed
      if: steps.detect-trigger.outputs.trigger_type == 'pr_closed' && steps.detect-trigger.outputs.pr_merged == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const prNumber = ${{ steps.detect-trigger.outputs.pr_number }};

          // Get PR details to find linked issue
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber
          });

          // Extract issue numbers from PR body
          const body = pr.body || '';
          const patterns = [
            /(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\s+#(\d+)/gi,
            /#(\d+)/g
          ];

          const linkedIssues = new Set();
          for (const pattern of patterns) {
            let match;
            while ((match = pattern.exec(body)) !== null) {
              linkedIssues.add(parseInt(match[1], 10));
            }
          }

          core.info(`PR #${prNumber} potentially resolves issues: [${Array.from(linkedIssues).join(', ')}]`);
          core.setOutput('linked_issues', Array.from(linkedIssues).join(','));

          // For each linked issue, check if it's a subtask and find parent
          for (const issueNumber of linkedIssues) {
            try {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });

              // Check if issue body mentions parent
              const parentMatch = (issue.body || '').match(/Parent Issue:\s*#(\d+)/i);
              if (parentMatch) {
                const parentNumber = parseInt(parentMatch[1], 10);
                core.info(`Found parent issue: #${parentNumber}`);
                core.setOutput('parent_issue_number', parentNumber);
                core.setOutput('subtask_number', issueNumber);
                return { parentNumber, subtaskNumber: issueNumber };
              }
            } catch (error) {
              core.warning(`Could not check issue #${issueNumber}: ${error.message}`);
            }
          }

          core.info('No parent issue found for this PR');

    - name: Check for Newly Ready Subtasks
      id: check-newly-ready
      if: steps.handle-pr-closed.outputs.parent_issue_number != ''
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const parentNumber = parseInt('${{ steps.handle-pr-closed.outputs.parent_issue_number }}', 10);
          const completedSubtask = parseInt('${{ steps.handle-pr-closed.outputs.subtask_number }}', 10);

          // Get parent issue
          const { data: parentIssue } = await github.rest.issues.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: parentNumber
          });

          // Extract all subtasks
          const body = parentIssue.body || '';
          const regex = /- \[([ x])\] #(\d+)/g;
          const subtasks = [];
          let match;

          while ((match = regex.exec(body)) !== null) {
            const isCompleted = match[1] === 'x';
            const issueNumber = parseInt(match[2], 10);

            if (!isCompleted && issueNumber !== completedSubtask) {
              subtasks.push(issueNumber);
            }
          }

          core.info(`Found ${subtasks.length} remaining incomplete subtasks`);
          core.setOutput('remaining_subtasks', subtasks.join(','));
          core.setOutput('parent_number', parentNumber);

          // Now we need to re-run dependency analysis for remaining subtasks
          // This would follow the same logic as before but is abbreviated here
          // to avoid duplication. In practice, we'd call a reusable function.

          return subtasks;

    - name: Post Progress Comment
      if: steps.handle-pr-closed.outputs.parent_issue_number != ''
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.token }}
        script: |
          const parentNumber = parseInt('${{ steps.handle-pr-closed.outputs.parent_issue_number }}', 10);
          const completedSubtask = parseInt('${{ steps.handle-pr-closed.outputs.subtask_number }}', 10);

          let comment = `## ðŸŽ‰ Subtask Completed\n\n`;
          comment += `Subtask #${completedSubtask} has been merged!\n\n`;
          comment += `Checking for newly unblocked subtasks...\n\n`;
          comment += `---\n`;
          comment += `*The Copilot Subtask Manager will automatically assign ready subtasks.*`;

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: parentNumber,
            body: comment
          });

          core.info('âœ… Posted progress comment on parent issue');
