name: Copilot Subtask Manager

on:
  issues:
    types: [assigned]
  pull_request:
    types: [closed]

permissions:
  issues: write
  pull-requests: read
  contents: read

jobs:
  manage-copilot-subtasks:
    runs-on: ubuntu-latest
    name: Auto-assign Copilot to ready subtasks

    steps:
      - name: Check if Copilot was assigned to parent issue
        id: check-copilot-assignment
        if: github.event_name == 'issues' && github.event.action == 'assigned'
        uses: actions/github-script@v7
        with:
          script: |
            const assignee = context.payload.assignee.login;
            const isCopilot = assignee === 'copilot' || assignee.includes('copilot');

            core.info(`Assignee: ${assignee}`);
            core.info(`Is Copilot: ${isCopilot}`);

            core.setOutput('is-copilot', isCopilot);
            core.setOutput('issue-number', context.payload.issue.number);

      - name: Get subtasks and analyze dependencies
        id: analyze-subtasks
        if: steps.check-copilot-assignment.outputs.is-copilot == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;

            // Get the parent issue
            const { data: parentIssue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            core.info(`Parent issue #${issueNumber}: ${parentIssue.title}`);

            // Find subtasks by looking for issues that reference this parent
            // GitHub uses tasklists and sub-issues which are shown in the timeline
            const { data: timeline } = await github.rest.issues.listEventsForTimeline({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            // Also search for issues with parent label or in issue body
            const { data: allIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            // Find subtasks by checking for parent references in labels or body
            const subtasks = allIssues.filter(issue => {
              const hasParentLabel = issue.labels.some(label =>
                label.name === `parent:${issueNumber}`
              );
              const bodyMentionsParent = issue.body &&
                (issue.body.includes(`#${issueNumber}`) ||
                 issue.body.includes(`Parent Issue: #${issueNumber}`));

              return hasParentLabel || bodyMentionsParent;
            });

            core.info(`Found ${subtasks.length} subtasks`);

            // Analyze dependencies for each subtask
            const subtaskAnalysis = subtasks.map(subtask => {
              const dependencies = [];

              // Parse dependencies from issue body and labels
              if (subtask.body) {
                // Look for "depends on #123" or "Depends: #123, #124"
                const dependsMatches = subtask.body.matchAll(/depends[- ]on:?\s*#(\d+)/gi);
                for (const match of dependsMatches) {
                  dependencies.push(parseInt(match[1]));
                }

                // Look for "Requires #123"
                const requiresMatches = subtask.body.matchAll(/requires:?\s*#(\d+)/gi);
                for (const match of requiresMatches) {
                  dependencies.push(parseInt(match[1]));
                }
              }

              // Check for dependency labels like "depends-on:#123"
              subtask.labels.forEach(label => {
                const match = label.name.match(/depends-on:#?(\d+)/i);
                if (match) {
                  dependencies.push(parseInt(match[1]));
                }
              });

              // Check if subtask already has assignees
              const hasAssignees = subtask.assignees && subtask.assignees.length > 0;

              return {
                number: subtask.number,
                title: subtask.title,
                dependencies: [...new Set(dependencies)], // Remove duplicates
                hasAssignees,
                state: subtask.state
              };
            });

            // Determine which subtasks are ready (no unresolved dependencies)
            const readySubtasks = subtaskAnalysis.filter(subtask => {
              if (subtask.hasAssignees) {
                core.info(`Subtask #${subtask.number} already has assignees, skipping`);
                return false;
              }

              if (subtask.dependencies.length === 0) {
                core.info(`Subtask #${subtask.number} has no dependencies, ready to assign`);
                return true;
              }

              // Check if all dependencies are closed
              const unresolvedDeps = subtask.dependencies.filter(depNum => {
                const depSubtask = subtaskAnalysis.find(st => st.number === depNum);
                return !depSubtask || depSubtask.state !== 'closed';
              });

              if (unresolvedDeps.length === 0) {
                core.info(`Subtask #${subtask.number} has all dependencies resolved, ready to assign`);
                return true;
              }

              core.info(`Subtask #${subtask.number} has ${unresolvedDeps.length} unresolved dependencies: ${unresolvedDeps.join(', ')}`);
              return false;
            });

            core.setOutput('ready-subtasks', JSON.stringify(readySubtasks.map(st => st.number)));
            core.setOutput('all-subtasks', JSON.stringify(subtaskAnalysis));

            return {
              totalSubtasks: subtasks.length,
              readyCount: readySubtasks.length,
              readySubtasks: readySubtasks.map(st => st.number)
            };

      - name: Assign Copilot to ready subtasks
        if: steps.check-copilot-assignment.outputs.is-copilot == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const readySubtasks = JSON.parse('${{ steps.analyze-subtasks.outputs.ready-subtasks }}' || '[]');

            if (readySubtasks.length === 0) {
              core.info('No ready subtasks to assign');
              return;
            }

            const assignee = context.payload.assignee.login;
            const results = [];

            for (const subtaskNumber of readySubtasks) {
              try {
                await github.rest.issues.addAssignees({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: subtaskNumber,
                  assignees: [assignee]
                });

                core.info(`âœ“ Assigned ${assignee} to subtask #${subtaskNumber}`);
                results.push({ number: subtaskNumber, success: true });
              } catch (error) {
                core.error(`âœ— Failed to assign ${assignee} to subtask #${subtaskNumber}: ${error.message}`);
                results.push({ number: subtaskNumber, success: false, error: error.message });
              }
            }

            core.setOutput('assignment-results', JSON.stringify(results));

      - name: Post status comment on parent issue
        if: steps.check-copilot-assignment.outputs.is-copilot == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            const assignee = context.payload.assignee.login;
            const readySubtasks = JSON.parse('${{ steps.analyze-subtasks.outputs.ready-subtasks }}' || '[]');
            const allSubtasks = JSON.parse('${{ steps.analyze-subtasks.outputs.all-subtasks }}' || '[]');
            const results = JSON.parse('${{ steps.check-copilot-assignment.outputs.is-copilot }}' === 'true' ?
              '${{ steps.analyze-subtasks.outputs.ready-subtasks }}' : '[]');

            if (readySubtasks.length === 0 && allSubtasks.length === 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `ðŸ¤– **Copilot Subtask Manager**\n\nNo subtasks found for this issue. ${assignee} will work on the parent issue directly.`
              });
              return;
            }

            if (readySubtasks.length === 0) {
              const blockedSubtasks = allSubtasks.filter(st => !st.hasAssignees && st.dependencies.length > 0);
              const assignedSubtasks = allSubtasks.filter(st => st.hasAssignees);

              let comment = `ðŸ¤– **Copilot Subtask Manager**\n\n`;
              comment += `Found ${allSubtasks.length} subtask(s), but none are ready to assign:\n\n`;

              if (assignedSubtasks.length > 0) {
                comment += `**Already Assigned:**\n`;
                assignedSubtasks.forEach(st => {
                  comment += `- [ ] #${st.number} - ${st.title}\n`;
                });
                comment += `\n`;
              }

              if (blockedSubtasks.length > 0) {
                comment += `**Blocked by Dependencies:**\n`;
                blockedSubtasks.forEach(st => {
                  comment += `- [ ] #${st.number} - ${st.title} (depends on: ${st.dependencies.map(d => `#${d}`).join(', ')})\n`;
                });
              }

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: comment
              });
              return;
            }

            // Success case - assigned subtasks
            let comment = `ðŸ¤– **Copilot Subtask Manager**\n\n`;
            comment += `${assignee} has been assigned to ${readySubtasks.length} ready subtask(s):\n\n`;

            readySubtasks.forEach(subtaskNum => {
              const subtask = allSubtasks.find(st => st.number === subtaskNum);
              comment += `- [ ] #${subtaskNum}${subtask ? ` - ${subtask.title}` : ''}\n`;
            });

            const blockedSubtasks = allSubtasks.filter(st =>
              !readySubtasks.includes(st.number) &&
              !st.hasAssignees &&
              st.dependencies.length > 0
            );

            if (blockedSubtasks.length > 0) {
              comment += `\n**Waiting for Dependencies:**\n`;
              blockedSubtasks.forEach(st => {
                comment += `- [ ] #${st.number} - ${st.title} (depends on: ${st.dependencies.map(d => `#${d}`).join(', ')})\n`;
              });
              comment += `\n_These will be automatically assigned as dependencies are completed._`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: comment
            });

      # Handle PR completion to assign next subtasks
      - name: Check if closed PR is from a subtask
        id: check-subtask-completion
        if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const prBody = context.payload.pull_request.body || '';

            // Look for linked issues in PR body
            const issueMatches = prBody.matchAll(/(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\s+#(\d+)/gi);
            const linkedIssues = [];

            for (const match of issueMatches) {
              linkedIssues.push(parseInt(match[1]));
            }

            core.info(`PR #${prNumber} links to issues: ${linkedIssues.join(', ')}`);

            if (linkedIssues.length === 0) {
              core.info('No linked issues found, skipping subtask progression');
              return { hasLinkedIssue: false };
            }

            // Check if the linked issue is a subtask
            for (const issueNum of linkedIssues) {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNum
              });

              // Check if issue has parent label
              const parentLabel = issue.labels.find(label => label.name.startsWith('parent:'));

              if (parentLabel) {
                const parentNum = parseInt(parentLabel.name.split(':')[1]);
                core.info(`Issue #${issueNum} is a subtask of #${parentNum}`);

                core.setOutput('is-subtask', 'true');
                core.setOutput('subtask-number', issueNum);
                core.setOutput('parent-number', parentNum);

                return {
                  hasLinkedIssue: true,
                  isSubtask: true,
                  subtaskNumber: issueNum,
                  parentNumber: parentNum
                };
              }
            }

            core.info('Linked issues are not subtasks');
            return { hasLinkedIssue: true, isSubtask: false };

      - name: Find and assign next ready subtasks
        if: steps.check-subtask-completion.outputs.is-subtask == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const completedSubtaskNumber = parseInt('${{ steps.check-subtask-completion.outputs.subtask-number }}');
            const parentNumber = parseInt('${{ steps.check-subtask-completion.outputs.parent-number }}');

            core.info(`Subtask #${completedSubtaskNumber} completed, checking parent #${parentNumber} for next tasks`);

            // Get all open issues
            const { data: allIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });

            // Find all subtasks of this parent
            const subtasks = allIssues.filter(issue => {
              const hasParentLabel = issue.labels.some(label =>
                label.name === `parent:${parentNumber}`
              );
              return hasParentLabel;
            });

            core.info(`Found ${subtasks.length} remaining open subtasks for parent #${parentNumber}`);

            // Analyze which subtasks are now ready
            const subtaskAnalysis = subtasks.map(subtask => {
              const dependencies = [];

              if (subtask.body) {
                const dependsMatches = subtask.body.matchAll(/depends[- ]on:?\s*#(\d+)/gi);
                for (const match of dependsMatches) {
                  dependencies.push(parseInt(match[1]));
                }

                const requiresMatches = subtask.body.matchAll(/requires:?\s*#(\d+)/gi);
                for (const match of requiresMatches) {
                  dependencies.push(parseInt(match[1]));
                }
              }

              subtask.labels.forEach(label => {
                const match = label.name.match(/depends-on:#?(\d+)/i);
                if (match) {
                  dependencies.push(parseInt(match[1]));
                }
              });

              const hasAssignees = subtask.assignees && subtask.assignees.length > 0;

              return {
                number: subtask.number,
                title: subtask.title,
                dependencies: [...new Set(dependencies)],
                hasAssignees
              };
            });

            // Find subtasks that were blocked but are now ready
            const newlyReadySubtasks = [];

            for (const subtask of subtaskAnalysis) {
              if (subtask.hasAssignees) continue;

              // Check if this subtask depended on the completed one
              if (!subtask.dependencies.includes(completedSubtaskNumber)) continue;

              // Check if all other dependencies are also completed
              const unresolvedDeps = [];
              for (const depNum of subtask.dependencies) {
                if (depNum === completedSubtaskNumber) continue; // Just completed

                const { data: depIssue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: depNum
                });

                if (depIssue.state !== 'closed') {
                  unresolvedDeps.push(depNum);
                }
              }

              if (unresolvedDeps.length === 0) {
                core.info(`Subtask #${subtask.number} is now ready (all dependencies resolved)`);
                newlyReadySubtasks.push(subtask);
              }
            }

            if (newlyReadySubtasks.length === 0) {
              core.info('No newly unblocked subtasks found');

              // Post completion comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parentNumber,
                body: `ðŸ¤– **Subtask Completed**\n\nSubtask #${completedSubtaskNumber} has been completed!\n\nNo additional subtasks are ready to assign at this time.`
              });

              return;
            }

            // Assign Copilot to newly ready subtasks
            const copilotLogin = 'copilot'; // or context.payload.pull_request.user.login if it's Copilot

            for (const subtask of newlyReadySubtasks) {
              try {
                await github.rest.issues.addAssignees({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: subtask.number,
                  assignees: [copilotLogin]
                });

                core.info(`âœ“ Assigned ${copilotLogin} to subtask #${subtask.number}`);
              } catch (error) {
                core.error(`âœ— Failed to assign to subtask #${subtask.number}: ${error.message}`);
              }
            }

            // Post progress comment
            let comment = `ðŸ¤– **Subtask Completed**\n\n`;
            comment += `Subtask #${completedSubtaskNumber} has been completed! âœ…\n\n`;
            comment += `**Newly Assigned Subtasks:**\n`;

            newlyReadySubtasks.forEach(st => {
              comment += `- [ ] #${st.number} - ${st.title}\n`;
            });

            const stillBlocked = subtaskAnalysis.filter(st =>
              !st.hasAssignees &&
              !newlyReadySubtasks.some(nrs => nrs.number === st.number) &&
              st.dependencies.length > 0
            );

            if (stillBlocked.length > 0) {
              comment += `\n**Still Waiting:**\n`;
              stillBlocked.forEach(st => {
                comment += `- [ ] #${st.number} - ${st.title}\n`;
              });
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parentNumber,
              body: comment
            });
